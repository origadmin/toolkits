package argon2

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/origadmin/toolkits/crypto/hash/constants"
	"github.com/origadmin/toolkits/crypto/hash/internal/validator"
	"github.com/origadmin/toolkits/crypto/hash/types"
)

func TestParams_ParseAndString(t *testing.T) {
	tests := []struct {
		name     string
		params   string
		wantErr  bool
		validate func(*testing.T, *Params)
	}{
		{
			name:    "CompleteParameters",
			params:  "t:3,m:65536,p:4,k:32",
			wantErr: false,
			validate: func(t *testing.T, p *Params) {
				if p.TimeCost != 3 {
					t.Errorf("TimeCost = %v, want %v", p.TimeCost, 3)
				}
				if p.MemoryCost != 65536 {
					t.Errorf("MemoryCost = %v, want %v", p.MemoryCost, 65536)
				}
				if p.Threads != 4 {
					t.Errorf("Threads = %v, want %v", p.Threads, 4)
				}
				if p.KeyLength != 32 {
					t.Errorf("KeyLength = %v, want %v", p.KeyLength, 32)
				}
			},
		},
		{
			name:    "BoundaryTestMaximumMemoryCost",
			params:  "t:3,m:4294967295,p:4,k:32",
			wantErr: false,
			validate: func(t *testing.T, p *Params) {
				if p.TimeCost != 3 {
					t.Errorf("TimeCost = %v, want %v", p.TimeCost, 3)
				}
				if p.MemoryCost != 4294967295 {
					t.Errorf("MemoryCost = %v, want %v", p.MemoryCost, 4294967295)
				}
				if p.Threads != 4 {
					t.Errorf("Threads = %v, want %v", p.Threads, 4)
				}
				if p.KeyLength != 32 {
					t.Errorf("KeyLength = %v, want %v", p.KeyLength, 32)
				}
			},
		},
		{
			name:    "BoundaryTestMinimumMemoryCost",
			params:  "t:3,m:1,p:4,k:32",
			wantErr: false,
			validate: func(t *testing.T, p *Params) {
				if p.TimeCost != 3 {
					t.Errorf("TimeCost = %v, want %v", p.TimeCost, 3)
				}
				if p.MemoryCost != 1 {
					t.Errorf("MemoryCost = %v, want %v", p.MemoryCost, 1)
				}
				if p.Threads != 4 {
					t.Errorf("Threads = %v, want %v", p.Threads, 4)
				}
				if p.KeyLength != 32 {
					t.Errorf("KeyLength = %v, want %v", p.KeyLength, 32)
				}
			},
		},
		{
			name:    "InvalidParameterFormat",
			params:  "t:3,m:65536,p:4,k:32,invalid",
			wantErr: true,
		},
		{
			name:    "InvalidParameterValue",
			params:  "t:invalid,m:65536",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := validator.WithParams(&Params{})
			err := p.Validate(&types.Config{
				SaltLength:  16,
				ParamConfig: tt.params,
			})
			if (err != nil) != tt.wantErr {
				t.Errorf("parseParams() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr {
				return
			}
			if tt.validate != nil {
				tt.validate(t, p.Params())
			}

			// Test String method to ensure it's the inverse of parsing.
			// We parse the output of String() and compare the resulting struct
			// with the original one.
			if tt.params != "" {
				str := p.Params().String()
				p2 := validator.WithParams(&Params{})
				err := p2.Validate(&types.Config{
					ParamConfig: str,
					SaltLength:  16,
				})
				if err != nil {
					t.Fatalf("Failed to parse string generated by String() for Params '%s': %v", str, err)
				}

				if !reflect.DeepEqual(p.Params(), p2.Params()) {
					t.Errorf("Params after String()->Parse roundtrip do not match original. got %+v, want %+v", p2.Params(), p.Params())
				}
			}
		})
	}
}

func TestNewArgon2(t *testing.T) {
	tests := []struct {
		name    string
		config  *types.Config
		wantErr bool
	}{
		{
			name:    "Default config",
			config:  DefaultConfig(),
			wantErr: false,
		},
		{
			name: "Custom config",
			config: &types.Config{
				SaltLength: constants.DefaultSaltLength,
				ParamConfig: (&Params{
					TimeCost:   constants.DefaultTimeCost,
					MemoryCost: constants.DefaultMemoryCost,
					Threads:    constants.DefaultThreads,
					KeyLength:  32,
				}).String(),
			},
			wantErr: false,
		},
		{
			name: "Invalid config - zero time cost",
			config: &types.Config{
				SaltLength: constants.DefaultSaltLength,
				ParamConfig: (&Params{
					TimeCost:   0,
					MemoryCost: constants.DefaultMemoryCost,
					Threads:    constants.DefaultThreads,
					KeyLength:  32,
				}).String(),
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c, err := NewArgon2(argon2Type, tt.config)
			if (err != nil) != tt.wantErr {
				t.Errorf("NewArgon2() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr {
				if c == nil {
					t.Errorf("NewArgon2() returned nil, want non-nil")
					return
				}
				hash, err := c.Hash("password")
				if err != nil {
					t.Errorf("Hash() error = %v", err)
				}
				err = c.Verify(hash, "password")
				if err != nil {
					t.Errorf("Verify() error = %v", err)
				}
			}
		})
	}
}

func TestArgon2_HashAndVerify(t *testing.T) {
	testCases := []struct {
		name     string
		algType  types.Type
		password string
		salt     []byte
	}{
		{
			name: "Argon2id",
			algType: types.Type{
				Name: constants.ARGON2id,
			},
			password: "password123",
			salt:     []byte("somesalt"),
		},
		{
			name: "Argon2i",
			algType: types.Type{
				Name: constants.ARGON2i,
			},
			password: "anotherpassword",
			salt:     []byte("anothersalt"),
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a new Argon2 instance
			a, err := NewArgon2(tc.algType, DefaultConfig())
			if err != nil {
				t.Fatalf("failed to create Argon2 instance: %v", err)
			}

			// Test HashWithSalt
			parts, err := a.HashWithSalt(tc.password, tc.salt)
			if err != nil {
				t.Fatalf("HashWithSalt() error = %v", err)
			}

			if parts.Algorithm != tc.algType.String() {
				t.Errorf("HashWithSalt() algorithm = %v, want %v", parts.Algorithm, tc.algType.String())
			}

			// Verify the hash
			err = a.Verify(parts, tc.password)
			if err != nil {
				t.Errorf("Verify() with correct password failed: %v", err)
			}

			// Verify with incorrect password
			err = a.Verify(parts, "wrongpassword")
			if err == nil {
				t.Error("Verify() with incorrect password should have failed")
			}

			// Test Hash (which generates a random salt)
			parts, err = a.Hash(tc.password)
			if err != nil {
				t.Fatalf("Hash() error = %v", err)
			}

			// Verify the hash from Hash()
			err = a.Verify(parts, tc.password)
			if err != nil {
				t.Errorf("Verify() with hash from Hash() failed: %v", err)
			}
		})
	}
}

func TestArgon2_Hash_Error(t *testing.T) {
	// This test is a bit tricky as it requires mocking rand.RandomBytes.
	// For now, we'll just ensure the function doesn't panic with a valid config.
	c, err := NewArgon2(argon2Type, DefaultConfig())
	assert.NoError(t, err)
	_, err = c.Hash("password")
	assert.NoError(t, err)
}

func TestArgon2_Verify_Error(t *testing.T) {
	c, err := NewArgon2(argon2Type, DefaultConfig())
	assert.NoError(t, err)

	// Invalid algorithm
	err = c.Verify(&types.HashParts{Algorithm: "invalid"}, "password")
	assert.Error(t, err)

	// Invalid params
	hash, err := c.Hash("password")
	assert.NoError(t, err)
	hash.Params = map[string]string{"invalid": "param"}
	assert.Panics(t, func() {
		c.Verify(hash, "password")
	})

	// Wrong password
	hash, err = c.Hash("password")
	assert.NoError(t, err)
	err = c.Verify(hash, "wrongpassword")
	assert.Error(t, err)
}

func TestNewArgon2_Error(t *testing.T) {
	_, err := NewArgon2(types.Type{Name: "invalid"}, DefaultConfig())
	assert.Error(t, err)
}

func TestNewArgon2i_And_NewArgon2id(t *testing.T) {
	_, err := NewArgon2i(DefaultConfig())
	assert.NoError(t, err)

	_, err = NewArgon2id(DefaultConfig())
	assert.NoError(t, err)
}

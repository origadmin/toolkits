// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: config/v1/gateway.proto

package configv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Gateway with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Gateway) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Gateway with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GatewayMultiError, or nil if none found.
func (m *Gateway) ValidateAll() error {
	return m.validate(true)
}

func (m *Gateway) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	for idx, item := range m.GetEndpoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GatewayValidationError{
						field:  fmt.Sprintf("Endpoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GatewayValidationError{
						field:  fmt.Sprintf("Endpoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GatewayValidationError{
					field:  fmt.Sprintf("Endpoints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMiddlewares() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GatewayValidationError{
						field:  fmt.Sprintf("Middlewares[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GatewayValidationError{
						field:  fmt.Sprintf("Middlewares[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GatewayValidationError{
					field:  fmt.Sprintf("Middlewares[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetTlsStore()))
		i := 0
		for key := range m.GetTlsStore() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTlsStore()[key]
			_ = val

			// no validation rules for TlsStore[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GatewayValidationError{
							field:  fmt.Sprintf("TlsStore[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GatewayValidationError{
							field:  fmt.Sprintf("TlsStore[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GatewayValidationError{
						field:  fmt.Sprintf("TlsStore[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GatewayMultiError(errors)
	}

	return nil
}

// GatewayMultiError is an error wrapping multiple validation errors returned
// by Gateway.ValidateAll() if the designated constraints aren't met.
type GatewayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GatewayMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GatewayMultiError) AllErrors() []error { return m }

// GatewayValidationError is the validation error returned by Gateway.Validate
// if the designated constraints aren't met.
type GatewayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayValidationError) ErrorName() string { return "GatewayValidationError" }

// Error satisfies the builtin error interface
func (e GatewayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGateway.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayValidationError{}

// Validate checks the field values on TLS with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *TLS) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TLS with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TLSMultiError, or nil if none found.
func (m *TLS) ValidateAll() error {
	return m.validate(true)
}

func (m *TLS) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Insecure

	// no validation rules for Cacert

	// no validation rules for Cert

	// no validation rules for Key

	// no validation rules for ServerName

	if len(errors) > 0 {
		return TLSMultiError(errors)
	}

	return nil
}

// TLSMultiError is an error wrapping multiple validation errors returned by
// TLS.ValidateAll() if the designated constraints aren't met.
type TLSMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TLSMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TLSMultiError) AllErrors() []error { return m }

// TLSValidationError is the validation error returned by TLS.Validate if the
// designated constraints aren't met.
type TLSValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSValidationError) ErrorName() string { return "TLSValidationError" }

// Error satisfies the builtin error interface
func (e TLSValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLS.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSValidationError{}

// Validate checks the field values on PriorityConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PriorityConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PriorityConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PriorityConfigMultiError,
// or nil if none found.
func (m *PriorityConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PriorityConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	for idx, item := range m.GetEndpoints() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PriorityConfigValidationError{
						field:  fmt.Sprintf("Endpoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PriorityConfigValidationError{
						field:  fmt.Sprintf("Endpoints[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PriorityConfigValidationError{
					field:  fmt.Sprintf("Endpoints[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PriorityConfigMultiError(errors)
	}

	return nil
}

// PriorityConfigMultiError is an error wrapping multiple validation errors
// returned by PriorityConfig.ValidateAll() if the designated constraints
// aren't met.
type PriorityConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PriorityConfigMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PriorityConfigMultiError) AllErrors() []error { return m }

// PriorityConfigValidationError is the validation error returned by
// PriorityConfig.Validate if the designated constraints aren't met.
type PriorityConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PriorityConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PriorityConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PriorityConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PriorityConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PriorityConfigValidationError) ErrorName() string { return "PriorityConfigValidationError" }

// Error satisfies the builtin error interface
func (e PriorityConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPriorityConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PriorityConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PriorityConfigValidationError{}

// Validate checks the field values on Endpoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Endpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Endpoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EndpointMultiError, or nil
// if none found.
func (m *Endpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *Endpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Method

	// no validation rules for Description

	// no validation rules for Protocol

	// no validation rules for Timeout

	for idx, item := range m.GetMiddlewares() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EndpointValidationError{
						field:  fmt.Sprintf("Middlewares[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EndpointValidationError{
						field:  fmt.Sprintf("Middlewares[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EndpointValidationError{
					field:  fmt.Sprintf("Middlewares[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBackends() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EndpointValidationError{
						field:  fmt.Sprintf("Backends[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EndpointValidationError{
						field:  fmt.Sprintf("Backends[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EndpointValidationError{
					field:  fmt.Sprintf("Backends[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRetry()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EndpointValidationError{
					field:  "Retry",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EndpointValidationError{
					field:  "Retry",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRetry()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EndpointValidationError{
				field:  "Retry",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Metadata

	// no validation rules for Host

	if len(errors) > 0 {
		return EndpointMultiError(errors)
	}

	return nil
}

// EndpointMultiError is an error wrapping multiple validation errors returned
// by Endpoint.ValidateAll() if the designated constraints aren't met.
type EndpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EndpointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EndpointMultiError) AllErrors() []error { return m }

// EndpointValidationError is the validation error returned by
// Endpoint.Validate if the designated constraints aren't met.
type EndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndpointValidationError) ErrorName() string { return "EndpointValidationError" }

// Error satisfies the builtin error interface
func (e EndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndpointValidationError{}

// Validate checks the field values on Middleware with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Middleware) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Middleware with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MiddlewareMultiError, or
// nil if none found.
func (m *Middleware) ValidateAll() error {
	return m.validate(true)
}

func (m *Middleware) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Options

	// no validation rules for Required

	if len(errors) > 0 {
		return MiddlewareMultiError(errors)
	}

	return nil
}

// MiddlewareMultiError is an error wrapping multiple validation errors
// returned by Middleware.ValidateAll() if the designated constraints aren't met.
type MiddlewareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MiddlewareMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MiddlewareMultiError) AllErrors() []error { return m }

// MiddlewareValidationError is the validation error returned by
// Middleware.Validate if the designated constraints aren't met.
type MiddlewareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MiddlewareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MiddlewareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MiddlewareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MiddlewareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MiddlewareValidationError) ErrorName() string { return "MiddlewareValidationError" }

// Error satisfies the builtin error interface
func (e MiddlewareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMiddleware.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MiddlewareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MiddlewareValidationError{}

// Validate checks the field values on Backend with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Backend) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Backend with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BackendMultiError, or nil if none found.
func (m *Backend) ValidateAll() error {
	return m.validate(true)
}

func (m *Backend) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Target

	if all {
		switch v := interface{}(m.GetHealthCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BackendValidationError{
					field:  "HealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BackendValidationError{
					field:  "HealthCheck",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHealthCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BackendValidationError{
				field:  "HealthCheck",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Tls

	// no validation rules for TlsConfigName

	// no validation rules for Metadata

	if m.Weight != nil {
		// no validation rules for Weight
	}

	if len(errors) > 0 {
		return BackendMultiError(errors)
	}

	return nil
}

// BackendMultiError is an error wrapping multiple validation errors returned
// by Backend.ValidateAll() if the designated constraints aren't met.
type BackendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BackendMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BackendMultiError) AllErrors() []error { return m }

// BackendValidationError is the validation error returned by Backend.Validate
// if the designated constraints aren't met.
type BackendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BackendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BackendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BackendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BackendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BackendValidationError) ErrorName() string { return "BackendValidationError" }

// Error satisfies the builtin error interface
func (e BackendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBackend.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BackendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BackendValidationError{}

// Validate checks the field values on HealthCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthCheck) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthCheck with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthCheckMultiError, or
// nil if none found.
func (m *HealthCheck) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthCheck) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Endpoint

	if len(errors) > 0 {
		return HealthCheckMultiError(errors)
	}

	return nil
}

// HealthCheckMultiError is an error wrapping multiple validation errors
// returned by HealthCheck.ValidateAll() if the designated constraints aren't met.
type HealthCheckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthCheckMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthCheckMultiError) AllErrors() []error { return m }

// HealthCheckValidationError is the validation error returned by
// HealthCheck.Validate if the designated constraints aren't met.
type HealthCheckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthCheckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthCheckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthCheckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthCheckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthCheckValidationError) ErrorName() string { return "HealthCheckValidationError" }

// Error satisfies the builtin error interface
func (e HealthCheckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthCheck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthCheckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthCheckValidationError{}

// Validate checks the field values on Retry with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Retry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Retry with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RetryMultiError, or nil if none found.
func (m *Retry) ValidateAll() error {
	return m.validate(true)
}

func (m *Retry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Attempts

	// no validation rules for PerTryTimeout

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RetryValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RetryValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RetryValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RetryMultiError(errors)
	}

	return nil
}

// RetryMultiError is an error wrapping multiple validation errors returned by
// Retry.ValidateAll() if the designated constraints aren't met.
type RetryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryMultiError) AllErrors() []error { return m }

// RetryValidationError is the validation error returned by Retry.Validate if
// the designated constraints aren't met.
type RetryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryValidationError) ErrorName() string { return "RetryValidationError" }

// Error satisfies the builtin error interface
func (e RetryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryValidationError{}

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Condition.(type) {
	case *Condition_ByStatusCode:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ByStatusCode
	case *Condition_ByHeader:
		if v == nil {
			err := ConditionValidationError{
				field:  "Condition",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetByHeader()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "ByHeader",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConditionValidationError{
						field:  "ByHeader",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetByHeader()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConditionValidationError{
					field:  "ByHeader",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on Condition_Header with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Condition_Header) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition_Header with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Condition_HeaderMultiError, or nil if none found.
func (m *Condition_Header) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition_Header) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Value

	if len(errors) > 0 {
		return Condition_HeaderMultiError(errors)
	}

	return nil
}

// Condition_HeaderMultiError is an error wrapping multiple validation errors
// returned by Condition_Header.ValidateAll() if the designated constraints
// aren't met.
type Condition_HeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Condition_HeaderMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Condition_HeaderMultiError) AllErrors() []error { return m }

// Condition_HeaderValidationError is the validation error returned by
// Condition_Header.Validate if the designated constraints aren't met.
type Condition_HeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Condition_HeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Condition_HeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Condition_HeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Condition_HeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Condition_HeaderValidationError) ErrorName() string { return "Condition_HeaderValidationError" }

// Error satisfies the builtin error interface
func (e Condition_HeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition_Header.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Condition_HeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Condition_HeaderValidationError{}

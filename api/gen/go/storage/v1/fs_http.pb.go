// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             (unknown)
// source: storage/v1/fs.proto

package storagev1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationStorageServiceDelete = "/storage.v1.StorageService/Delete"
const OperationStorageServiceFinalizeUpload = "/storage.v1.StorageService/FinalizeUpload"
const OperationStorageServiceInitiateUpload = "/storage.v1.StorageService/InitiateUpload"
const OperationStorageServiceList = "/storage.v1.StorageService/List"
const OperationStorageServiceMkdir = "/storage.v1.StorageService/Mkdir"
const OperationStorageServiceRename = "/storage.v1.StorageService/Rename"
const OperationStorageServiceStat = "/storage.v1.StorageService/Stat"

type StorageServiceHTTPServer interface {
	// Delete Delete a file or directory.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// FinalizeUpload Finalizes a chunked upload, assembling the chunks into the final file.
	FinalizeUpload(context.Context, *FinalizeUploadRequest) (*FinalizeUploadResponse, error)
	// InitiateUpload Initiates a new chunked upload and returns an upload_id.
	InitiateUpload(context.Context, *InitiateUploadRequest) (*InitiateUploadResponse, error)
	// List List files and directories at a given path.
	List(context.Context, *ListRequest) (*ListResponse, error)
	// Mkdir Create a new directory.
	Mkdir(context.Context, *MkdirRequest) (*MkdirResponse, error)
	// Rename Rename or move a file or directory.
	Rename(context.Context, *RenameRequest) (*RenameResponse, error)
	// Stat Get information about a single file or directory.
	Stat(context.Context, *StatRequest) (*StatResponse, error)
}

func RegisterStorageServiceHTTPServer(s *http.Server, srv StorageServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/storage/list", _StorageService_List0_HTTP_Handler(srv))
	r.GET("/v1/storage/stat", _StorageService_Stat0_HTTP_Handler(srv))
	r.POST("/v1/storage/mkdir", _StorageService_Mkdir0_HTTP_Handler(srv))
	r.POST("/v1/storage/delete", _StorageService_Delete0_HTTP_Handler(srv))
	r.POST("/v1/storage/rename", _StorageService_Rename0_HTTP_Handler(srv))
	r.POST("/v1/storage/uploads:initiate", _StorageService_InitiateUpload0_HTTP_Handler(srv))
	r.POST("/v1/storage/uploads:finalize", _StorageService_FinalizeUpload0_HTTP_Handler(srv))
}

func _StorageService_List0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.List(ctx, req.(*ListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListResponse)
		return ctx.Result(200, reply)
	}
}

func _StorageService_Stat0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in StatRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceStat)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Stat(ctx, req.(*StatRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*StatResponse)
		return ctx.Result(200, reply)
	}
}

func _StorageService_Mkdir0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MkdirRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceMkdir)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Mkdir(ctx, req.(*MkdirRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*MkdirResponse)
		return ctx.Result(200, reply)
	}
}

func _StorageService_Delete0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceDelete)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Delete(ctx, req.(*DeleteRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteResponse)
		return ctx.Result(200, reply)
	}
}

func _StorageService_Rename0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RenameRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceRename)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Rename(ctx, req.(*RenameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RenameResponse)
		return ctx.Result(200, reply)
	}
}

func _StorageService_InitiateUpload0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in InitiateUploadRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceInitiateUpload)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.InitiateUpload(ctx, req.(*InitiateUploadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*InitiateUploadResponse)
		return ctx.Result(200, reply)
	}
}

func _StorageService_FinalizeUpload0_HTTP_Handler(srv StorageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in FinalizeUploadRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationStorageServiceFinalizeUpload)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.FinalizeUpload(ctx, req.(*FinalizeUploadRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*FinalizeUploadResponse)
		return ctx.Result(200, reply)
	}
}

type StorageServiceHTTPClient interface {
	Delete(ctx context.Context, req *DeleteRequest, opts ...http.CallOption) (rsp *DeleteResponse, err error)
	FinalizeUpload(ctx context.Context, req *FinalizeUploadRequest, opts ...http.CallOption) (rsp *FinalizeUploadResponse, err error)
	InitiateUpload(ctx context.Context, req *InitiateUploadRequest, opts ...http.CallOption) (rsp *InitiateUploadResponse, err error)
	List(ctx context.Context, req *ListRequest, opts ...http.CallOption) (rsp *ListResponse, err error)
	Mkdir(ctx context.Context, req *MkdirRequest, opts ...http.CallOption) (rsp *MkdirResponse, err error)
	Rename(ctx context.Context, req *RenameRequest, opts ...http.CallOption) (rsp *RenameResponse, err error)
	Stat(ctx context.Context, req *StatRequest, opts ...http.CallOption) (rsp *StatResponse, err error)
}

type StorageServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewStorageServiceHTTPClient(client *http.Client) StorageServiceHTTPClient {
	return &StorageServiceHTTPClientImpl{client}
}

func (c *StorageServiceHTTPClientImpl) Delete(ctx context.Context, in *DeleteRequest, opts ...http.CallOption) (*DeleteResponse, error) {
	var out DeleteResponse
	pattern := "/v1/storage/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationStorageServiceDelete))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *StorageServiceHTTPClientImpl) FinalizeUpload(ctx context.Context, in *FinalizeUploadRequest, opts ...http.CallOption) (*FinalizeUploadResponse, error) {
	var out FinalizeUploadResponse
	pattern := "/v1/storage/uploads:finalize"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationStorageServiceFinalizeUpload))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *StorageServiceHTTPClientImpl) InitiateUpload(ctx context.Context, in *InitiateUploadRequest, opts ...http.CallOption) (*InitiateUploadResponse, error) {
	var out InitiateUploadResponse
	pattern := "/v1/storage/uploads:initiate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationStorageServiceInitiateUpload))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *StorageServiceHTTPClientImpl) List(ctx context.Context, in *ListRequest, opts ...http.CallOption) (*ListResponse, error) {
	var out ListResponse
	pattern := "/v1/storage/list"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationStorageServiceList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *StorageServiceHTTPClientImpl) Mkdir(ctx context.Context, in *MkdirRequest, opts ...http.CallOption) (*MkdirResponse, error) {
	var out MkdirResponse
	pattern := "/v1/storage/mkdir"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationStorageServiceMkdir))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *StorageServiceHTTPClientImpl) Rename(ctx context.Context, in *RenameRequest, opts ...http.CallOption) (*RenameResponse, error) {
	var out RenameResponse
	pattern := "/v1/storage/rename"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationStorageServiceRename))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *StorageServiceHTTPClientImpl) Stat(ctx context.Context, in *StatRequest, opts ...http.CallOption) (*StatResponse, error) {
	var out StatResponse
	pattern := "/v1/storage/stat"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationStorageServiceStat))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

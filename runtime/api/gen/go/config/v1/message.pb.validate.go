// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: config/v1/message.proto

package configv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Message with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MessageMultiError, or nil if none found.
func (m *Message) ValidateAll() error {
	return m.validate(true)
}

func (m *Message) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _Message_Type_InLookup[m.GetType()]; !ok {
		err := MessageValidationError{
			field:  "Type",
			reason: "value must be in list [none mqtt kafka rabbitmq activemq nats nsq pulsar redis rocketmq]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetMqtt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Mqtt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Mqtt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMqtt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Mqtt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKafka()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Kafka",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRabbitmq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Rabbitmq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Rabbitmq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRabbitmq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Rabbitmq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActivemq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Activemq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Activemq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActivemq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Activemq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Nats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Nats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Nats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNsq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Nsq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Nsq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNsq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Nsq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPulsar()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Pulsar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Pulsar",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPulsar()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Pulsar",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRedis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Redis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRocketmq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Rocketmq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MessageValidationError{
					field:  "Rocketmq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRocketmq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MessageValidationError{
				field:  "Rocketmq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MessageMultiError(errors)
	}

	return nil
}

// MessageMultiError is an error wrapping multiple validation errors returned
// by Message.ValidateAll() if the designated constraints aren't met.
type MessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageMultiError) AllErrors() []error { return m }

// MessageValidationError is the validation error returned by Message.Validate
// if the designated constraints aren't met.
type MessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageValidationError) ErrorName() string { return "MessageValidationError" }

// Error satisfies the builtin error interface
func (e MessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageValidationError{}

var _Message_Type_InLookup = map[string]struct{}{
	"none":     {},
	"mqtt":     {},
	"kafka":    {},
	"rabbitmq": {},
	"activemq": {},
	"nats":     {},
	"nsq":      {},
	"pulsar":   {},
	"redis":    {},
	"rocketmq": {},
}

// Validate checks the field values on Message_MQTT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message_MQTT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_MQTT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Message_MQTTMultiError, or
// nil if none found.
func (m *Message_MQTT) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_MQTT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_MQTTMultiError(errors)
	}

	return nil
}

// Message_MQTTMultiError is an error wrapping multiple validation errors
// returned by Message_MQTT.ValidateAll() if the designated constraints aren't met.
type Message_MQTTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_MQTTMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_MQTTMultiError) AllErrors() []error { return m }

// Message_MQTTValidationError is the validation error returned by
// Message_MQTT.Validate if the designated constraints aren't met.
type Message_MQTTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_MQTTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_MQTTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_MQTTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_MQTTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_MQTTValidationError) ErrorName() string { return "Message_MQTTValidationError" }

// Error satisfies the builtin error interface
func (e Message_MQTTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_MQTT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_MQTTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_MQTTValidationError{}

// Validate checks the field values on Message_Kafka with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message_Kafka) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_Kafka with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Message_KafkaMultiError, or
// nil if none found.
func (m *Message_Kafka) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_Kafka) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_KafkaMultiError(errors)
	}

	return nil
}

// Message_KafkaMultiError is an error wrapping multiple validation errors
// returned by Message_Kafka.ValidateAll() if the designated constraints
// aren't met.
type Message_KafkaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_KafkaMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_KafkaMultiError) AllErrors() []error { return m }

// Message_KafkaValidationError is the validation error returned by
// Message_Kafka.Validate if the designated constraints aren't met.
type Message_KafkaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_KafkaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_KafkaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_KafkaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_KafkaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_KafkaValidationError) ErrorName() string { return "Message_KafkaValidationError" }

// Error satisfies the builtin error interface
func (e Message_KafkaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_Kafka.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_KafkaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_KafkaValidationError{}

// Validate checks the field values on Message_RabbitMQ with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Message_RabbitMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_RabbitMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Message_RabbitMQMultiError, or nil if none found.
func (m *Message_RabbitMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_RabbitMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_RabbitMQMultiError(errors)
	}

	return nil
}

// Message_RabbitMQMultiError is an error wrapping multiple validation errors
// returned by Message_RabbitMQ.ValidateAll() if the designated constraints
// aren't met.
type Message_RabbitMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_RabbitMQMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_RabbitMQMultiError) AllErrors() []error { return m }

// Message_RabbitMQValidationError is the validation error returned by
// Message_RabbitMQ.Validate if the designated constraints aren't met.
type Message_RabbitMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_RabbitMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_RabbitMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_RabbitMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_RabbitMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_RabbitMQValidationError) ErrorName() string { return "Message_RabbitMQValidationError" }

// Error satisfies the builtin error interface
func (e Message_RabbitMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_RabbitMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_RabbitMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_RabbitMQValidationError{}

// Validate checks the field values on Message_ActiveMQ with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Message_ActiveMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_ActiveMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Message_ActiveMQMultiError, or nil if none found.
func (m *Message_ActiveMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_ActiveMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_ActiveMQMultiError(errors)
	}

	return nil
}

// Message_ActiveMQMultiError is an error wrapping multiple validation errors
// returned by Message_ActiveMQ.ValidateAll() if the designated constraints
// aren't met.
type Message_ActiveMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_ActiveMQMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_ActiveMQMultiError) AllErrors() []error { return m }

// Message_ActiveMQValidationError is the validation error returned by
// Message_ActiveMQ.Validate if the designated constraints aren't met.
type Message_ActiveMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_ActiveMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_ActiveMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_ActiveMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_ActiveMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_ActiveMQValidationError) ErrorName() string { return "Message_ActiveMQValidationError" }

// Error satisfies the builtin error interface
func (e Message_ActiveMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_ActiveMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_ActiveMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_ActiveMQValidationError{}

// Validate checks the field values on Message_NATS with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message_NATS) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_NATS with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Message_NATSMultiError, or
// nil if none found.
func (m *Message_NATS) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_NATS) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_NATSMultiError(errors)
	}

	return nil
}

// Message_NATSMultiError is an error wrapping multiple validation errors
// returned by Message_NATS.ValidateAll() if the designated constraints aren't met.
type Message_NATSMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_NATSMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_NATSMultiError) AllErrors() []error { return m }

// Message_NATSValidationError is the validation error returned by
// Message_NATS.Validate if the designated constraints aren't met.
type Message_NATSValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_NATSValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_NATSValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_NATSValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_NATSValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_NATSValidationError) ErrorName() string { return "Message_NATSValidationError" }

// Error satisfies the builtin error interface
func (e Message_NATSValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_NATS.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_NATSValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_NATSValidationError{}

// Validate checks the field values on Message_NSQ with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message_NSQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_NSQ with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Message_NSQMultiError, or
// nil if none found.
func (m *Message_NSQ) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_NSQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_NSQMultiError(errors)
	}

	return nil
}

// Message_NSQMultiError is an error wrapping multiple validation errors
// returned by Message_NSQ.ValidateAll() if the designated constraints aren't met.
type Message_NSQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_NSQMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_NSQMultiError) AllErrors() []error { return m }

// Message_NSQValidationError is the validation error returned by
// Message_NSQ.Validate if the designated constraints aren't met.
type Message_NSQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_NSQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_NSQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_NSQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_NSQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_NSQValidationError) ErrorName() string { return "Message_NSQValidationError" }

// Error satisfies the builtin error interface
func (e Message_NSQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_NSQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_NSQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_NSQValidationError{}

// Validate checks the field values on Message_Pulsar with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message_Pulsar) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_Pulsar with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Message_PulsarMultiError,
// or nil if none found.
func (m *Message_Pulsar) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_Pulsar) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_PulsarMultiError(errors)
	}

	return nil
}

// Message_PulsarMultiError is an error wrapping multiple validation errors
// returned by Message_Pulsar.ValidateAll() if the designated constraints
// aren't met.
type Message_PulsarMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_PulsarMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_PulsarMultiError) AllErrors() []error { return m }

// Message_PulsarValidationError is the validation error returned by
// Message_Pulsar.Validate if the designated constraints aren't met.
type Message_PulsarValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_PulsarValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_PulsarValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_PulsarValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_PulsarValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_PulsarValidationError) ErrorName() string { return "Message_PulsarValidationError" }

// Error satisfies the builtin error interface
func (e Message_PulsarValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_Pulsar.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_PulsarValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_PulsarValidationError{}

// Validate checks the field values on Message_Redis with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Message_Redis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_Redis with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Message_RedisMultiError, or
// nil if none found.
func (m *Message_Redis) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_Redis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	if len(errors) > 0 {
		return Message_RedisMultiError(errors)
	}

	return nil
}

// Message_RedisMultiError is an error wrapping multiple validation errors
// returned by Message_Redis.ValidateAll() if the designated constraints
// aren't met.
type Message_RedisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_RedisMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_RedisMultiError) AllErrors() []error { return m }

// Message_RedisValidationError is the validation error returned by
// Message_Redis.Validate if the designated constraints aren't met.
type Message_RedisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_RedisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_RedisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_RedisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_RedisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_RedisValidationError) ErrorName() string { return "Message_RedisValidationError" }

// Error satisfies the builtin error interface
func (e Message_RedisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_Redis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_RedisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_RedisValidationError{}

// Validate checks the field values on Message_RocketMQ with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Message_RocketMQ) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Message_RocketMQ with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Message_RocketMQMultiError, or nil if none found.
func (m *Message_RocketMQ) ValidateAll() error {
	return m.validate(true)
}

func (m *Message_RocketMQ) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Endpoint

	// no validation rules for Codec

	// no validation rules for EnableTrace

	// no validation rules for NameServerDomain

	// no validation rules for AccessKey

	// no validation rules for SecretKey

	// no validation rules for SecurityToken

	// no validation rules for Namespace

	// no validation rules for InstanceName

	// no validation rules for GroupName

	if len(errors) > 0 {
		return Message_RocketMQMultiError(errors)
	}

	return nil
}

// Message_RocketMQMultiError is an error wrapping multiple validation errors
// returned by Message_RocketMQ.ValidateAll() if the designated constraints
// aren't met.
type Message_RocketMQMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Message_RocketMQMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Message_RocketMQMultiError) AllErrors() []error { return m }

// Message_RocketMQValidationError is the validation error returned by
// Message_RocketMQ.Validate if the designated constraints aren't met.
type Message_RocketMQValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Message_RocketMQValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Message_RocketMQValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Message_RocketMQValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Message_RocketMQValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Message_RocketMQValidationError) ErrorName() string { return "Message_RocketMQValidationError" }

// Error satisfies the builtin error interface
func (e Message_RocketMQValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessage_RocketMQ.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Message_RocketMQValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Message_RocketMQValidationError{}
